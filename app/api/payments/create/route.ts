import { NextRequest, NextResponse } from 'next/server'
import { getStripe } from '@/lib/stripe'
import { createClient as createSupabaseAdmin } from '@supabase/supabase-js'

function adminClient() {
  return createSupabaseAdmin(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  )
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { event_id, ime, email } = body

    if (!event_id || !ime || !email) {
      return NextResponse.json({ error: 'Nedostaju podaci' }, { status: 400 })
    }

    const supabase = adminClient()
    const stripe = getStripe()

    // Load event
    const { data: event, error: eventError } = await supabase
      .from('events')
      .select(`
        id, slug, naziv, status, datum, rok_uplate,
        cijena_vlasnika, service_fee,
        min_sudionika, max_sudionika,
        owner_id,
        owners ( stripe_account_id, stripe_onboarding_complete )
      `)
      .eq('id', event_id)
      .eq('status', 'active')
      .single()

    if (eventError || !event) {
      return NextResponse.json({ error: 'Termin nije pronađen ili nije aktivan' }, { status: 404 })
    }

    // Validate deadline
    const now = new Date()
    const rok = new Date(event.rok_uplate)
    if (rok < now) {
      return NextResponse.json({ error: 'Rok uplate je prošao' }, { status: 400 })
    }

    // Check capacity (count paid + confirmed)
    const { count: paidCount } = await supabase
      .from('payments')
      .select('*', { count: 'exact', head: true })
      .eq('event_id', event_id)
      .in('status', ['paid', 'confirmed'])

    // Event is full → client should show waiting list form
    if ((paidCount ?? 0) >= event.max_sudionika) {
      return NextResponse.json({ full: true }, { status: 200 })
    }

    // Get owner's Stripe account
    const owner = Array.isArray(event.owners)
      ? event.owners[0] as { stripe_account_id: string | null; stripe_onboarding_complete: boolean }
      : event.owners as { stripe_account_id: string | null; stripe_onboarding_complete: boolean } | null

    if (!owner?.stripe_onboarding_complete || !owner?.stripe_account_id) {
      return NextResponse.json({ error: 'Plaćanje nije postavljeno za ovaj termin' }, { status: 400 })
    }

    const stripeAccountId = owner.stripe_account_id

    // ── Hybrid capture logic ───────────────────────────────────────────────
    // ≤6 days until event → manual capture (hold card, charge only if min met)
    // 7+ days until event → automatic capture (charge now, refund if min not met)
    const eventDate = new Date(event.datum)
    const daysUntilEvent = Math.ceil((eventDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24))
    const captureMethod = daysUntilEvent <= 6 ? 'manual' : 'automatic'

    const iznos_total = event.cijena_vlasnika + event.service_fee // total in cents
    const iznos_vlasnika = event.cijena_vlasnika
    const iznos_fee = event.service_fee

    // Create Stripe PaymentIntent via Connect
    const paymentIntent = await stripe.paymentIntents.create(
      {
        amount: iznos_total,
        currency: 'eur',
        capture_method: captureMethod,
        application_fee_amount: iznos_fee,
        metadata: {
          event_id: event.id,
          event_slug: event.slug,
          guest_ime: ime,
          guest_email: email,
        },
        receipt_email: email,
        description: event.naziv,
      },
      { stripeAccount: stripeAccountId }
    )

    // Generate cancel token and create payment record
    const { error: insertError } = await supabase
      .from('payments')
      .insert({
        event_id: event.id,
        ime,
        email,
        iznos_total,
        iznos_vlasnika,
        iznos_fee,
        stripe_payment_intent_id: paymentIntent.id,
        capture_method: captureMethod,
        status: 'pending',
        // cancel_token is auto-generated by DB default (gen_random_uuid())
      })

    if (insertError) {
      console.error('[payments/create] DB insert failed:', insertError)
      await stripe.paymentIntents.cancel(paymentIntent.id, {}, { stripeAccount: stripeAccountId })
      return NextResponse.json({ error: 'Greška pri kreiranju uplate' }, { status: 500 })
    }

    return NextResponse.json({
      clientSecret: paymentIntent.client_secret,
      captureMethod,
      stripeAccountId,
      iznos_total,
    })
  } catch (error) {
    console.error('[payments/create] error:', error)
    return NextResponse.json({ error: 'Server greška' }, { status: 500 })
  }
}
